{
    "contents" : "\n# the difference between array(matrix) and list(data.frame)\n# is that: array can only contain one type of data\n# while list can store different types of data\n\nlibrary(RUnit)\n\ntest.create.matrix <- function() {\n  matrix1 <- matrix(1:12,nrow=4)\n  checkIdentical(\"matrix\",class(matrix1))\n  checkIdentical( c(4L,3L),dim(matrix1) )\n  \n  # by default, numbers are filled into matrix by column\n  checkIdentical( c(1L,5L,9L),matrix1[1,] )\n  checkIdentical( c(9L,10L,11L,12L),matrix1[,3])\n  \n  # fill the matrix by row\n  matrix2 <- matrix(1:12,nrow=4,byrow=TRUE)\n  checkIdentical( c(1L,2L,3L),matrix2[1,] )\n  checkIdentical( c(3L,6L,9L,12L),matrix2[,3])\n}\n\ntest.vec2matrix.assign.dim <- function() {\n  v <- 1:20\n  dim(v) <- c(4,5)\n  checkTrue( is.matrix(v) )\n  \n  m <- matrix(1:20,nrow=4)\n  \n  checkIdentical(m,v)\n}\n\ntest.dims <- function() {\n  matrix1 <- matrix(1:12,nrow=4)\n  checkIdentical( c(4L,3L),dim(matrix1) )\n  checkIdentical(4L,nrow(matrix1))\n  checkIdentical(3L,ncol(matrix1))\n  checkIdentical(12L,length(matrix1))\n}\n\ntest.reshape.by.reassign.dims <- function() {\n  matrix1 <- matrix(1:12,nrow=4)\n  checkIdentical(c(4L,3L),dim(matrix1))\n  \n  dim(matrix1) <- c(6,2)\n  checkIdentical(c(6L,2L),dim(matrix1))\n  checkIdentical(c(1L,7L),matrix1[1,])\n  \n  # if the new dimension doesn't match the length\n  # an error will be raised\n  checkException( dim(matrix1) <- c(2,3) )\n}\n\ntest.names.get <- function() {\n  rownames <- paste(\"row\",1:4,sep=\"\")\n  colnames <- paste(\"col\",1:3,sep=\"\")\n  matrix1 <- matrix(1:12,nrow=4,dimnames = list(rownames,colnames))\n  \n  checkIdentical(rownames,rownames(matrix1))\n  checkIdentical(colnames,colnames(matrix1))\n  checkIdentical(list(rownames,colnames),dimnames(matrix1))\n}\n\ntest.index.slice1 <- function() {\n  rownames <- paste(\"row\",1:4,sep=\"\")\n  colnames <- paste(\"col\",1:3,sep=\"\")\n  wholematrix <- matrix(1:12,nrow=4,dimnames = list(rownames,colnames))\n  \n  # mix the way to index\n  checkEquals( matrix(c(2,3,10,11),nrow=2),\n               wholematrix[c(2,3),c(\"col1\",\"col3\")],\n               check.attributes = FALSE,\n               checkNames = FALSE)\n}\n\ntest.index.slice2 <- function() {\n  rownames <- paste(\"row\",1:2,sep=\"\")\n  colnames <- paste(\"col\",1:3,sep=\"\")\n  wholematrix <- matrix(c(9,8,7,6,1,2),nrow=2,dimnames = list(rownames,colnames))\n  \n  # a single index just treat the matrix as a vector\n  checkTrue( wholematrix[3] == 7)\n  checkEquals(matrix(c(9,8,1,2),nrow=2), \n              wholematrix[,c(\"col1\",\"col3\")],\n              check.attributes=FALSE)\n  \n  checkEquals( c(8,6,2),wholematrix[c(\"row2\"),],check.attributes=FALSE)\n  checkEqualsNumeric( c(8,6,2),wholematrix[c(\"row2\"),])\n}\n\ntest.concatenate<- function() {\n  # first convert matrix to vector (column wise), and then concatenate\n  # and return vector too\n  m1 <- matrix(1:4,nrow=2)\n  m2 <- matrix(5:8,nrow=2)\n  \n  checkEquals( 1:8, c(m1,m2))\n  checkEquals( matrix(1:8,nrow=2),cbind(m1,m2) )\n  checkEquals( matrix(c(1,2,5,6,3,4,7,8),nrow=4),rbind(m1,m2) )\n}\n\ntest.elementwise.math <- function() {\n  m1 <- matrix(1:4,nrow=2)\n  m2 <- matrix(5:8,nrow=2)\n  \n  checkEquals( matrix(c(6,8,10,12),nrow=2), m1+m2 )\n  \n  # element-wise multiply\n  checkEquals( matrix(c(5,12,21,32),nrow=2), m1*m2 )\n  \n  # dimension not match, it will throw an exception\n  dim(m2) <- c(4,1)\n  checkException( m1+m2,\"mismatch dimensions will thrown an exception\")\n}\n\ntest.matrix.multiply <- function() {\n  m1 <- matrix(1:6,nrow=2)\n  m2 <- matrix(7:12,nrow=3)\n  checkException( m1 * m2,\"non-conformable for element-wise multiply\")\n  \n  checkEquals(matrix(c(76,100,103,136),nrow=2),m1 %*% m2)\n  checkEquals(matrix(c(27,30,33,61,68,75,95,106,117),nrow=3),m2 %*% m1)\n}\n\ntest.matrix.vector.multiply <- function() {\n  # matrix can multiply vector directly\n  # no need to convert vector to matrix first\n  m <- matrix(1:4,nrow=2)\n  v <- 5:6\n  \n  elementwise_product <- matrix(c(5,12,15,24),nrow=2)\n  checkEquals(elementwise_product,m * v)\n  \n  algebra_product <- matrix(c(23,34),nrow=2)\n  checkEquals(algebra_product,m %*% v)\n}\n\ntest.vector.inner.product <- function() {\n  v1 <- 1:3\n  v2 <- 4:6\n  \n  inner_product <- v1 %*% v2\n  checkIdentical(\"matrix\",class(inner_product))\n  checkIdentical(c(1L,1L),dim(inner_product))\n  \n  scalar <- drop(inner_product)\n  checkTrue(32 == scalar)\n}\n\ntest.vector.outer.product <- function() {\n  v1 <- 1:3\n  v2 <- 4:6\n  \n  outer_product <- v1 %o% v2\n  expected <- matrix(c(4,8,12,5,10,15,6,12,18),nrow=3)\n  checkEquals(expected,outer_product)\n  \n  checkEquals(t(expected),v2 %o% v1)\n}\n\ntest.transpose <- function() {\n  m <- matrix(1:4,nrow=2)\n  checkIdentical( matrix(c(1L,3L,2L,4L),nrow=2),t(m))\n}\n\ntest.inverse <- function() {\n  m <- matrix(1:4,nrow=2)\n  inverse_m <- solve(m)\n  \n  unit_matrix = diag(rep(1,2))\n  checkEquals(unit_matrix,m %*% inverse_m)\n  checkEquals(unit_matrix,inverse_m %*% m)\n}\n\n\n\n\n\n",
    "created" : 1442354690325.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3469046487",
    "id" : "69C849CB",
    "lastKnownWriteTime" : 1425324529,
    "path" : "D:/study/Practice/TestDrivenLearn/R/testr/runit_array_matrix.R",
    "project_path" : "runit_array_matrix.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}