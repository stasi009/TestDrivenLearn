package test

import org.scalatest.Spec

sealed class GenericTypeTest extends Spec {

  object `basic demo` {

    sealed class Node[T] {
      private var _value: T = _
      var next: Node[T] = _

      def value = _value
      def value_=(newvalue: T) = _value = newvalue
    }

    def `test generic type` = {
      val intnode = new Node[Int]
      intnode.value = 9
      assert(intnode.value == 9)
      intnode.next = new Node[Int]

      val strnode = new Node[String]
      strnode.value = "scala"
      assert(strnode.value == "scala")
      strnode.next = new Node[String]
    } //def

  } //object

  object `test boundary` {

    sealed class Ball(val radius: Float) extends Ordered[Ball] {
      // compare must return an integer, so we must use "round"
      override def compare(other: Ball) = (radius - other.radius).round

      // when using "==" to invoke "equals"
      // "==" will always check whether the right operand is null or not
      // so we can save the effort, and don't need to check whether the input is null or not
      override def equals(other: Any) = {
        other match {
          case otherball: Ball => (radius - otherball.radius).abs < 1e-6
          case _ => false
        } //match
      } //def

      override def hashCode = radius.round
    }

    // we must use <%, this is called "view bound"
    // that is because, Int doesn't extend Ordered
    // but it has an implicit conversion which can convert Int to RichInt which extends that trait
    // so we must use "<%" other than "<:"
    def getmin[T <% Ordered[T]](x: T, y: T) = {
      if (x < y) x else y
    }

    def `test upper/view boundary` = {
      // --------------- built in types
      assert(getmin(1, 2) == 1)
      assert(getmin("stasi","kgb") == "kgb")
      
      // --------------- user-defined type
      assert(getmin(new Ball(1),new Ball(0.5f)) == new Ball(0.5f))
    }

  } //object

}