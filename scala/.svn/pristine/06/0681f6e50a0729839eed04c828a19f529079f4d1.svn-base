package test

import org.scalatest.Spec

sealed class ArrayTest extends Spec {
  
  object `basic operations` {
    
    def `initialize arrays` = {
      // use constructor, primitive type are initialized to be zero
      val intarray = new Array[Int](10)
      assertResult(10)(intarray.length)
      assert(intarray forall {_ == 0})
      
      // use constructor, reference type are initialized to be null
      val strarray = new Array[String](11)
      assertResult(11)(strarray.length)
      assert(strarray forall {_ == null})
      
      // use companion object's apply method
      val txts = Array("stasi","kgb")
      assertResult(2)(txts.length)
      assertResult("stasi")(txts(0))
      assertResult("kgb")(txts(1))
    }
    
    def `array is mutable` = {
      val original = Array(1,2,3)
      val reference = original
      
      // change in place
      reference(1) = 200
      assertResult(200)(original(1))
      assert(original sameElements Array(1,200,3))
    }
    
    def `to buffer` = {
      val a = Array(1,2)
      
      val b = a.toBuffer
      b += (3,4)
      
      assert(b sameElements Array(1,2,3,4))
      assert(a sameElements Array(1,2))// the original array is not modified
    }
    
    def `functional sample 1` = {
      val x = Array(1,2,3,4)
      val y = x filter{_%2==0} map{_*2}
      
      // same type as the input collection
      assert(y.isInstanceOf[Array[Int]])
      assert(y sameElements Array(4,8))
    }
    
    def `common algorithms` = {
      val a = Array(4,6,8,1,5)
      assertResult(24)(a.sum)
      assertResult(8)(a.max)
      assertResult(1)(a.min)
    }
    
    def `test sorted` = {
       val x = Array(4,6,8,1,5)
       val y = x.sorted
       assert(y sameElements Array(1,4,5,6,8))
    }
    
    def `sort in place` = {
      val x = Array(4,6,8,1,5)
      util.Sorting.quickSort(x)
      assert(x sameElements Array(1,4,5,6,8))
    }
    
  }
  
  object `array equality` {
    
    // since Array still uses the default "equals"
    // so "==" still checks on "reference equality"
    // test whether two names points to the same object or not
    def `default ==` = {
      val original = Array(1,2,3)
      val sameRef = original
      val sameContent = Array(1,2,3)
      
      assert(original == sameRef)
      assert(original != sameContent)
    }
    
    def `eq and equals` = {
      val original = Array(1,2,3)
      val sameRef = original
      val sameContent = Array(1,2,3)
      
      assert(original eq sameRef)
      assert(original equals sameRef)
      assert(! (original equals sameContent ))
    }
    
    def `check sameElements` = {
      val original = Array(1,2,3)
      val sameElem_sameOrder = Array(1,2,3)
      val sameElem_diffOrder = Array(3,2,1)
      
      // not the same object
      assert(original != sameElem_sameOrder)
      // true, when same elements in same order
      assert(original sameElements sameElem_sameOrder)
      // false, when same elements but different order
      assert(!(original sameElements sameElem_diffOrder))
    }
  }// equality check on array
  
  object `multi-dim arrays` {
    
    def `matrix-like array` = {
      val (nrows,ncols) = (3,4)
      val matrix = Array.ofDim[Int](nrows,ncols)
      assert(matrix.length == nrows)
      
      val (r,c) = (1,2)
      matrix(r)(c) = 99
      assertResult(99)(matrix(r)(c))
    }
    
    def `ragged array` = {
      val triangle = new Array[Array[Int]](10)
      for (r <- 0 until triangle.length) {
        triangle(i) = new Array[Int](r+1)
      }
    }
  }

}