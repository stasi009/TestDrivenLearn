package test

import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.io.ObjectInputStream
import java.io.ObjectOutputStream
import org.scalatest.Spec

sealed class SerializeTest extends Spec {

  def serializeCopy[T](src: T) = {
    val byteOutStream = new ByteArrayOutputStream
    val objOutStream = new ObjectOutputStream(byteOutStream)
    objOutStream.writeObject(src)

    val byteInStream = new ByteArrayInputStream(byteOutStream.toByteArray)
    val objInStream = new ObjectInputStream(byteInStream)
    val cpy = objInStream.readObject()

    objOutStream.close()
    objInStream.close()

    cpy.asInstanceOf[T]
  } //def

  object `test basic types` {

    def `test primitive type` = {
      assert(serializeCopy(9) == 9)
      assert(serializeCopy("stasi") == "stasi")
    } //def

    def `test collections` = {

      assert(serializeCopy(Seq(1, 2, 3)) == List(1, 2, 3))

      val srcArray = Array(7, 8, 9)
      val cpyArray = serializeCopy(srcArray)
      assert(srcArray sameElements cpyArray)

    } //def

    /*
     * I want to call reset to reuse the output stream
     * in order to serialize multiple objects by using the same output stream
     * however, below way won't work
     * unfortunately, I haven't figure out the correct way
     */
    def `incorrect reset 1` = {
      val byteOutStream = new ByteArrayOutputStream
      val objOutStream = new ObjectOutputStream(byteOutStream)

      byteOutStream.reset()
      objOutStream.writeObject(999)

      // val byteInStream = new ByteArrayInputStream(byteOutStream.toByteArray)
      // val objInStream = new ObjectInputStream(byteInStream)
      // intercept[java.io.StreamCorruptedException] { objInStream.readObject() }
    } //def

  } //object

}//class