package test

import org.scalatest.Spec
import collection.mutable.ArrayBuffer

sealed class TraitTest extends Spec {

  object `demo 1` {

    trait Logger {
      def log(msg: String): Unit
      def info(msg: String) = log("Info: " + msg)
      def warn(msg: String) = log("Warning: " + msg)
      def severe(msg: String) = log("Severe: " + msg)
    }

    trait ForgetLogger extends Logger {
      // no need to use "override" for a abstract member
      // "override" is optional
      abstract override def log(msg: String) = super.log("")
    }

    trait IndexedLogger extends Logger {
      private var _counter = 0

      // "abstract" force this trait must mixin with a trait which has concrete implementation
      abstract override def log(msg: String) = {
        _counter += 1
        super.log(s"${_counter} - $msg")
      }
    }

    // one guideline to remember is: never use "abstract fields" in the constructor
    trait ShorterLogger extends Logger {
      val _maxLength: Int // wait to be overidden

      abstract override def log(msg: String) = {
        super.log {
          if (msg.length <= _maxLength) msg
          else msg.substring(0, _maxLength - 3) + "..."
        }
      }//def
    }
    
    sealed class Process extends Logger {
      val _messages = ArrayBuffer[String]()
      
      def run() {
        info("a")
        warn("b")
        severe("c")
        info("d")
      }
      
      override def log(msg: String) = {
        _messages += msg
      }
      
      def messages = _messages
    }
    
    def `basic operation` = {
      val p = new Process()
      p.run()
      
      assertResult(Seq("Info: a","Warning: bc","Severe: c","Info: d"))(p.messages.toSeq)
    }  

  } //object

}