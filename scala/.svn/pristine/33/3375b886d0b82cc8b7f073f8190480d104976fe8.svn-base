package test

import org.scalatest.Spec
import collection.mutable.ArrayBuffer

sealed class TraitTest extends Spec {

  object `demo 1` {

    trait Logger {
      def log(msg: String): Unit
      def info(msg: String) = log("Info: " + msg)
      def warn(msg: String) = log("Warning: " + msg)
      def severe(msg: String) = log("Severe: " + msg)
    }

    trait ForgetLogger extends Logger {
      // no need to use "override" for a abstract member
      // "override" is optional
      abstract override def log(msg: String) = super.log("")
    }

    trait IndexedLogger extends Logger {
      private var _counter = 0

      // "abstract" force this trait must mixin with a trait which has concrete implementation
      abstract override def log(msg: String) = {
        _counter += 1
        super.log(s"${_counter}-$msg")
      }
    }

    // one guideline to remember is: never use "abstract fields" in the constructor
    trait ShorterLogger extends Logger {
      val maxLength: Int // wait to be overidden

      abstract override def log(msg: String) = {
        super.log {
          if (msg.length <= maxLength) msg
          else msg.substring(0, maxLength - 3) + "..."
        }
      } //def
    }

    sealed class Process extends Logger {
      val _messages = ArrayBuffer[String]()

      def run() {
        info("a")
        warn("b")
        severe("c")
        info("d")
      }

      override def log(msg: String) = { _messages += msg }

      def messages = _messages
    }

    def `basic operation` = {
      val p = new Process()
      p.run()
      assertResult(Seq("Info: a", "Warning: b", "Severe: c", "Info: d"))(p.messages.toSeq)
    }

    def `demo mixin 1` = {
      val p = new Process with ForgetLogger
      p.run()
      assert(p.messages forall {_.isEmpty})
    }
    
    def `demo mixin 2` = {
      val p = new Process() with IndexedLogger
      p.run()
      assertResult(Seq("1-Info: a", "2-Warning: b", "3-Severe: c", "4-Info: d"))(p.messages.toSeq)
    }
   

  } //object

}